Flutter Questions 1–150 (Question then Answer on next line)

1. What rendering engine does Flutter use?
Skia

2. Which IDE plugins are officially supported for Flutter development?
VS Code and Android Studio/IntelliJ

3. Primary advantage of Flutter's write-once-run-anywhere?
Single codebase for multiple platforms

4. What does AOT compilation provide?
Fast startup time and predictable performance

5. Command to create a Flutter project?
flutter create project_name

6. Purpose of pubspec.yaml?
Defines project dependencies, assets, metadata

7. Keyword determined at compile time?
const

8. What does JIT enable?
Hot reload

9. Which design systems does Flutter support?
Material Design and Cupertino

10. Purpose of main()?
Entry point of the application

11. What does runApp() do?
Makes widget root of widget tree

12. What does sound null safety guarantee?
Non-nullable variables cannot be null

13. Which platforms can Flutter deploy to?
Mobile, web, desktop

14. Symbol for async programming?
async/await

15. Purpose of Flutter SDK bin directory?
Contains flutter and dart executables

16. Root of Flutter app widget tree?
MaterialApp or CupertinoApp

17. mainAxis vs crossAxis?
Main axis vs perpendicular axis alignment

18. When does build() run?
When setState() or parent rebuilds

19. Widget allowing overlap?
Stack

20. Scrollable list widget?
ListView

21. Purpose of const widget?
Compile-time optimization and reuse

22. Purpose of Expanded?
Make child fill available space

23. Padding widget?
Padding

24. StatefulWidget lifecycle?
createState → initState → build → dispose

25. Flexible vs Expanded?
Flexible allows smaller size; Expanded forces fill

26. Load network image?
Image.network()

27. Purpose of GlobalKey?
Access widget state from anywhere

28. Purpose of SafeArea?
Avoid system UI intrusions

29. Card widget?
Card

30. ValueKey vs UniqueKey?
Value-based vs always unique

31. Ripple effect widget?
InkWell

32. Circular loading widget?
CircularProgressIndicator

33. Use of RepaintBoundary?
Isolate repaints

34. LayoutBuilder provides?
Parent constraints

35. Add spacing?
SizedBox or Spacer

36. Trigger rebuild in Provider?
notifyListeners()

37. Purpose of MultiProvider?
Provide multiple state objects

38. Consumer vs Selector?
Selector rebuilds only on specific changes

39. What is a Stream?
Sequence of async events

40. Purpose of Consumer?
Listens to Provider and rebuilds

41. Purpose of StreamController?
Manage streams

42. Riverpod advantage?
Compile-safe, no BuildContext

43. Where to call setState()?
Inside State object

44. Purpose of ChangeNotifierProvider.value()?
Provide existing ChangeNotifier

45. What is a Sink?
Add data to Stream

46. What does context.read() do?
Read provider once

47. When lift state up?
When multiple widgets need shared state

48. Purpose of ProxyProvider?
Provider depending on other providers

49. setState after dispose?
Throws error

50. Ephemeral vs app state?
Local UI vs shared state

51. Go back?
Navigator.pop(context)

52. push vs pushNamed?
Route object vs route name

53. onGenerateRoute?
Generates dynamic routes

54. Long press callback?
onLongPress

55. Text input widget?
TextField

56. Prevent pop?
WillPopScope returning false

57. Purpose of TextEditingController?
Manage text and cursor

58. Slide transition?
SlideTransition

59. Form.of(context)?
Access FormState

60. pushReplacementNamed?
Replaces route

61. Keyboard type?
keyboardType

62. NavigatorObserver?
Monitors navigation events

63. Custom page transition?
PageRouteBuilder

64. Double tap gesture?
onDoubleTap

65. Deep linking?
Open screens via URL

66. HTTP read method?
GET

67. async/await?
Handle async operations

68. jsonEncode vs jsonDecode?
Dart→JSON / JSON→Dart

69. Reactive DB?
Isar or Moor/Drift

70. FutureBuilder?
UI based on Future state

71. compute()?
Run heavy tasks on isolate

72. Dio timeouts?
connectTimeout & receiveTimeout

73. StreamBuilder waiting?
Based on ConnectionState

74. json_serializable benefit?
Generates JSON parsing code

75. Save SharedPreferences?
setString(), setInt(), etc.

76. Pagination?
Load data in chunks

77. Auth token handling?
Add token to headers

78. snapshots()?
Real-time updates

79. Efficient list?
ListView.builder

80. Optimistic update?
Update UI before server confirms

81. Purpose of unit testing?
Test individual functions

82. User interaction testing?
Integration testing

83. Purpose of mockito?
Mock dependencies

84. Build APK?
flutter build apk

85. CI/CD?
Continuous Integration/Deployment

101. Flutter used for?
Cross-platform development

102. Language used?
Dart

103. Check setup?
flutter doctor

104. Instant change feature?
Hot Reload

105. Null safety prevents?
Null reference errors

106. Basic UI building block?
Widgets

107. No mutable state widget?
StatelessWidget

108. Vertical layout?
Column

109. MediaQuery purpose?
Screen info

110. When use Keys?
Preserve state in lists

111. Trigger rebuild?
setState()

112. Provider purpose?
State management & DI

113. BLoC meaning?
Business Logic Component

114. Local vs global state?
Widget-only vs shared

115. Class extended for Provider?
ChangeNotifier

116. Detect gestures?
GestureDetector

117. Navigate to screen?
Navigator.push(...MaterialPageRoute...)

118. Transition animation?
Hero animation

119. Return data on pop?
Navigator.pop(context, data)

120. Form with validation?
Form + TextFormField

121. HTTP packages?
http or dio

122. JSON serialization?
Convert JSON ↔ Dart

123. Local storage?
SharedPreferences

124. Firestore ID?
Document ID

125. Scrollable list?
ListView.builder

126. Layers of Clean Architecture?
Presentation, Domain, Data

127. Business logic layer?
Domain

128. Repository purpose?
Abstract data sources

129. NoteModel vs NoteEntity?
JSON vs business logic

130. Dependency injection?
Provide objects without coupling

131. DI package?
GetIt

132. Benefit of Use Cases?
Single business operation

133. Result pattern?
Handle success/failure

134. Domain shouldn't depend on data because?
Dependency Inversion

135. Test units?
Unit testing

136. BLoC components?
Events, States, BLoC

137. Trigger BLoC logic?
Adding an Event

138. BLoC listening widget?
BlocBuilder or BlocListener

139. Event to create note?
CreateNote

140. What happens while processing?
Loading state

141. pushReplacement?
Replaces route

142. Async in BLoC?
emit() with try/catch

143. Wrong with creating repo in widget?
Tight coupling

144. Why fromJson/toJson?
JSON serialization

145. Purpose of json_serializable?
Auto-generate JSON code

146. Note creation flow?
UI → BLoC → UseCase → Repository → DataSource → Firebase

147. Why separate DataSource & Repository?
Raw data vs logic

148. Violation if UseCase calls DataSource?
Dependency Inversion Principle

149. Why more testable?
Loose coupling & DI

150. Handle Firebase exceptions?
Repository implementation
